name: Java CI and Publish

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Build and test
        run: mvn -B -e -DskipTests=false clean verify

  publish:
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))) ||
      (github.event_name == 'workflow_dispatch')
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up JDK 17 and configure Maven for OSSRH
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          server-id: ossrh
          server-username: MAVEN_USERNAME
          server-password: MAVEN_PASSWORD
          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
          gpg-passphrase: ${{ secrets.GPG_PASSPHRASE }}
        env:
          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}

      # diagnostics + explicit settings
      - name: Check OSSRH secrets availability
        run: |
          if [ -z "${{ secrets.OSSRH_USERNAME }}" ] || [ -z "${{ secrets.OSSRH_PASSWORD }}" ]; then
            echo "ERROR: OSSRH_USERNAME or OSSRH_PASSWORD is not available to this run."
            exit 1
          else
            echo "OSSRH secrets are present."
          fi
      
      - name: Deploy to OSSRH (release or snapshot)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -eo pipefail

          VERSION=$(mvn -q -Dexec.cleanupDaemonThreads=false -DforceStdout -Dexpression=project.version help:evaluate | tail -n 1)
          echo "Project version from POM: $VERSION"

          # If this run was triggered by an existing v* tag, perform a release deploy and stop.
          if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            echo "Detected release tag ${GITHUB_REF}; deploying a release with signing and staging."
            mvn -B -Prelease -DskipTests -Dgpg.passphrase=${GPG_PASSPHRASE} clean deploy
            exit 0
          fi

          # On main (or manually triggered), decide flow based on whether version is SNAPSHOT or not.
          if [[ "${GITHUB_REF}" == "refs/heads/main" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "$VERSION" == *-SNAPSHOT ]]; then
              echo "Snapshot version detected; deploying to OSSRH snapshot repository."
              mvn -B -DskipTests clean deploy
              exit 0
            fi

            # Non-SNAPSHOT version on main: perform automated release tagging, deploy, and then bump to next -SNAPSHOT.
            echo "Non-SNAPSHOT version on main detected; performing automated release."

            # Configure git for CI pushes
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            TAG="v${VERSION}"
            echo "Preparing tag ${TAG}"

            # Check if tag already exists remotely
            if git ls-remote --exit-code --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
              echo "Tag ${TAG} already exists on origin; will not recreate."
            else
              echo "Creating and pushing tag ${TAG}"
              git tag -a "${TAG}" -m "Release ${TAG}"
              git push origin "${TAG}"
            fi

            echo "Deploying release ${TAG} with signing and staging."
            mvn -B -Prelease -DskipTests -Dgpg.passphrase=${GPG_PASSPHRASE} clean deploy

            # Compute next development version and bump POM to -SNAPSHOT
            NEXT_DEV=""
            if [[ "$VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              NEXT_DEV="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.$((BASH_REMATCH[3]+1))-SNAPSHOT"
            elif [[ "$VERSION" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
              NEXT_DEV="${BASH_REMATCH[1]}.$((BASH_REMATCH[2]+1))-SNAPSHOT"
            elif [[ "$VERSION" =~ ^([0-9]+)$ ]]; then
              NEXT_DEV="$((BASH_REMATCH[1]+1))-SNAPSHOT"
            else
              echo "WARN: Could not parse version '$VERSION' semantically; defaulting to append .1-SNAPSHOT"
              NEXT_DEV="${VERSION}.1-SNAPSHOT"
            fi

            echo "Bumping project version to ${NEXT_DEV} for next development iteration."
            mvn -B -DskipTests versions:set -DnewVersion="${NEXT_DEV}" -DgenerateBackupPoms=false

            if ! git diff --quiet -- pom.xml; then
              git add pom.xml
              git commit -m "chore(release): start next development iteration ${NEXT_DEV} [skip ci]"
              git push origin HEAD:main
              echo "Pushed next development version ${NEXT_DEV} to main."
            else
              echo "No changes to pom.xml detected after version bump (unexpected)."
            fi

            exit 0
          else
            echo "Not on a release tag or main; no deployment performed."
            exit 0
          fi